"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[87028],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(n),m=s,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||a;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,o=new Array(a);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var u=2;u<a;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},21256:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>a,contentTitle:()=>o,metadata:()=>i,assets:()=>l,toc:()=>u,default:()=>c});var r=n(87462),s=(n(67294),n(3905));const a={title:"Experimental useController()",authors:["ntucker"],tags:["releases","rest-hooks","packages","usecontroller","resource","fetch"]},o=void 0,i={permalink:"/blog/2021/08/29/Experimental-useController",source:"@site/blog/2021-08-29-Experimental-useController.md",title:"Experimental useController()",description:"@rest-hooks/experimental is a new",date:"2021-08-29T00:00:00.000Z",formattedDate:"August 29, 2021",tags:[{label:"releases",permalink:"/blog/tags/releases"},{label:"rest-hooks",permalink:"/blog/tags/rest-hooks"},{label:"packages",permalink:"/blog/tags/packages"},{label:"usecontroller",permalink:"/blog/tags/usecontroller"},{label:"resource",permalink:"/blog/tags/resource"},{label:"fetch",permalink:"/blog/tags/fetch"}],readingTime:8.655,truncated:!0,authors:[{name:"Nathaniel Tucker",title:"Creator of Rest Hooks",url:"https://github.com/ntucker",imageURL:"https://github.com/ntucker.png",key:"ntucker"}],nextItem:{title:"Rest Hooks 4.2-4.5",permalink:"/blog/2020/02/18/Rest-Hooks-4.2-4.5"}},l={authorsImageUrls:[void 0]},u=[{value:"useController()",id:"usecontroller",children:[{value:"Usage",id:"usage",children:[]},{value:"Motivation",id:"motivation",children:[]},{value:"One hook, many endpoints",id:"one-hook-many-endpoints",children:[]},{value:"Completely flexible, variable arguments",id:"completely-flexible-variable-arguments",children:[]},{value:"Endpoint.update",id:"endpointupdate",children:[]},{value:"Resolution order",id:"resolution-order",children:[]}]},{value:"Resource.list().paginated()",id:"resourcelistpaginated",children:[{value:"Motivation",id:"motivation-1",children:[]},{value:"Solution",id:"solution",children:[]}]}],p={toc:u};function c({components:e,...t}){return(0,s.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@rest-hooks/experimental"},"@rest-hooks/experimental")," is a new\npackage that allows us to quickly iterate on new designs by using them in production, which provides\nfeedback in ways not possible at design and testing phase."),(0,s.kt)("p",null,"This package is ",(0,s.kt)("strong",{parentName:"p"},"not")," api stable. However, it is tested with the same rigor we expect with Rest Hooks\nas we use it in production. It is recommend to use this for providing feedback or playing with designs,\nunless you are willing to put in extra work to make migrations. Detailed migration guides will only be\nprovided upon upstreaming to the mainline packages."),(0,s.kt)("p",null,"Today this package comes with two new features:"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("a",{parentName:"strong",href:"#usecontroller"},"useController()"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const { fetch, invalidate, resetEntireStore } = useController();\nfetch(MyResource.detail(), { id });\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("a",{parentName:"strong",href:"#resourcelistpaginated"},"Resource.list().paginated()"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class NewsResource extends Resource {\n  static listPage<T extends typeof NewsResource>(this: T) {\n    return this.list().paginated(({ cursor, ...rest }) => [rest]);\n  }\n}\n")),(0,s.kt)("h2",{id:"usecontroller"},"useController()"),(0,s.kt)("h3",{id:"usage"},"Usage"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useController } from '@rest-hooks/experimental';\n\nfunction MyComponent({ id }) {\n  const { fetch, invalidate, resetEntireStore } = useController();\n\n  const handleRefresh = useCallback(\n    async e => {\n      await fetch(MyResource.detail(), { id });\n    },\n    [fetch, id],\n  );\n\n  const handleSuspend = useCallback(\n    async e => {\n      await invalidate(MyResource.detail(), { id });\n    },\n    [invalidate, id],\n  );\n\n  const handleLogout = useCallback(\n    async e => {\n      resetEntireStore();\n    },\n    [resetEntireStore],\n  );\n}\n")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/coinbase/rest-hooks/pull/1048"},"PR")),(0,s.kt)("h3",{id:"motivation"},"Motivation"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Consolidate, simplify hooks"),(0,s.kt)("li",{parentName:"ul"},"Consistent interface between managers and hooks"),(0,s.kt)("li",{parentName:"ul"},"Global referential equality available everywhere (managers and updaters)"),(0,s.kt)("li",{parentName:"ul"},"Simplify and consolidate TTL and error concepts"),(0,s.kt)("li",{parentName:"ul"},"Less code in hooks = less work on rendering leaf nodes"),(0,s.kt)("li",{parentName:"ul"},"Icing on cake: ez migration to EndpointInterface and flexible args support for hooks"),(0,s.kt)("li",{parentName:"ul"},"Future breaking changes can allow ez migration with version strings sent to ",(0,s.kt)("inlineCode",{parentName:"li"},"useController({version: 'v2'})"))),(0,s.kt)("h3",{id:"one-hook-many-endpoints"},"One hook, many endpoints"),(0,s.kt)("p",null,"The rules of hooks are very restrictive, so the less hooks you have to call, the more flexible. This also benefits render performance. In many cases you might want to fetch many different endpoints. What's worse is if you don't know which endpoints you might want to fetch upfront. With old design you'd have to hook up every ",(0,s.kt)("em",{parentName:"p"},"possible")," one. This really destroys fetch-as-render pattern, as you want to be able to prefetch based on possible routes."),(0,s.kt)("h4",{id:"before"},"Before"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const createUser = useFetcher(User.create());\nconst refreshUsers = useFetcher(User.list());\n\nreturn (\n  <form onSubmit={() => createUser({}, userPayload)}>\n    <button onClick={() => refreshUsers({})}>Refresh list</button>\n  </form>\n);\n")),(0,s.kt)("h4",{id:"after"},"After"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const { fetch } = useController();\n\nreturn (\n  <form onSubmit={() => fetch(User.create(), {}, userPayload)}>\n    <button onClick={() => fetch(User.list(), {})}>Refresh list</button>\n  </form>\n);\n")),(0,s.kt)("h3",{id:"completely-flexible-variable-arguments"},"Completely flexible, variable arguments"),(0,s.kt)("p",null,"The concept of params + body for arguments was introduced to try to provide the most flexible approach in a world where type enforcement wasn't that flexible. With TypeScript 4's variadic tuples, it's now possible to strongly type arbitrary arguments to a function in a ",(0,s.kt)("em",{parentName:"p"},"generic")," way. Furthermore, stumbling upon package.json's typeVersions, rest hooks can now publish multiple type versions to be compatible with different versions of typescript. This allows us to eagerly adopt TypeScript 4 features, while providing a usable TypeScript 3 experience."),(0,s.kt)("p",null,"Some common annoyances with the current parameter limitations are single-variable arguments like detail endpoints with an id, as well as no-argument case like a list endpoint or create endpoint."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const { fetch } = useController();\n\nreturn (\n  <form onSubmit={() => fetch(User.create(), userPayload)}>\n    <button onClick={() => fetch(User.list())}>Refresh list</button>\n  </form>\n);\n")),(0,s.kt)("p",null,"We'll also eventually bring this to the 'read' hooks like so:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"// notice username is just a string, rather than object\nconst user = useResource(User.detail(), username);\n// here we don't need arguments\nconst posts = useResource(Post.list());\n// but list() has it being optional, which means this also works:\nconst goodPosts = useResource(Post.list(), { good: true });\n// postId is a number in this case\nconst thePost = useResource(Post.detail(), postId);\n")),(0,s.kt)("h3",{id:"endpointupdate"},"Endpoint.update"),(0,s.kt)("p",null,"By normalizing ",(0,s.kt)("a",{parentName:"p",href:"https://resthooks.io/docs/api/Entity"},"Entities"),", Rest Hooks guarantees data integrity and consistency even down to the referential equality level. However, there are still some cases where side effects result in changes to the actual results themselves. The most common reason for this is creation of new entities. While 'creation' is almost universally the cause for this (as deletion is handled more simply by delete schemas), the structure of data and where created elements go is not universal."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},(0,s.kt)("strong",{parentName:"p"},"Start using this now!")," Though this is the only way to use the new Controller.fetch,\nendpoints with ",(0,s.kt)("inlineCode",{parentName:"p"},"update")," work with the old ",(0,s.kt)("a",{parentName:"p",href:"https://resthooks.io/docs/api/useFetcher"},"useFetcher()")," hook as well."))),(0,s.kt)("h4",{id:"before-1"},"Before"),(0,s.kt)("p",null,"Previously this was enabled by an optional third argument to the fetch ",(0,s.kt)("a",{parentName:"p",href:"https://resthooks.io/docs/api/useFetcher#updateparams-destendpoint-destparams-updatefunction"},"UpdateParams")," enabling programmatic changes that are also strictly type enforced to ensure the data integrity of the Rest Hooks store."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createArticle = useFetcher(ArticleResource.create());\n\ncreateArticle({}, { id: 1 }, [\n  [\n    ArticleResource.list(),\n    {},\n    (newArticleID: string, articleIDs: string[] | undefined) => [\n      ...(articleIDs || []),\n      newArticleID,\n    ],\n  ],\n]);\n")),(0,s.kt)("p",null,"While simple, this design had several shortcomings"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Only operates on the normalized results, often arrays of strings",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"This is non-intuitive as this doesn't relate directly to the data's form and requires understanding of internals"),(0,s.kt)("li",{parentName:"ul"},"Code is confusing with two ordered args and necessary default handling"),(0,s.kt)("li",{parentName:"ul"},"Lack of access to entities means sorting is not possible"),(0,s.kt)("li",{parentName:"ul"},"Can only update top level results, which means lists nested inside entities cannot be updated"))),(0,s.kt)("li",{parentName:"ul"},"Is provided as an argument to the fetch rather than endpoint",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Makes variable arguments impossible, and hard to reason about"),(0,s.kt)("li",{parentName:"ul"},"Makes pattern reuse still require explicit wiring"),(0,s.kt)("li",{parentName:"ul"},"Was thought to be more flexible than in 'fetchshape', as it has access to local variables in its event handler. However, Endpoints's can easily use ",(0,s.kt)("inlineCode",{parentName:"li"},".extend()")," to contextually override so this feature is moot."),(0,s.kt)("li",{parentName:"ul"},"Encourages antipatterns like writing hooks for specific endpoints")))),(0,s.kt)("h4",{id:"after-1"},"After"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Operate on the actual denormalized form - that is the same shape that is consumsed with a useResource()"),(0,s.kt)("li",{parentName:"ul"},"Move to Endpoint"),(0,s.kt)("li",{parentName:"ul"},"Take the denormalized response as arg to first function"),(0,s.kt)("li",{parentName:"ul"},"builder pattern to make updater definition easy",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"typeahead"),(0,s.kt)("li",{parentName:"ul"},"strong type enforcement"),(0,s.kt)("li",{parentName:"ul"},"much more readable than a size 3 tuple")))),(0,s.kt)("p",null,"Simplest case:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"type UserList = Denormalized<typeof userList['schema']>;\n\nconst createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>) => [\n    userList.bind().updater((users: UserList = []) => [newUser, ...users]),\n  ],\n});\n")),(0,s.kt)("p",null,"More updates:"),(0,s.kt)("details",{open:!0},(0,s.kt)("summary",null,(0,s.kt)("b",null,"Component.tsx")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const allusers = useResource(userList);\nconst adminUsers = useResource(userList, { admin: true });\nconst sortedUsers = useResource(userList, { sortBy: 'createdAt' });\n"))),(0,s.kt)("p",null,"The endpoint below ensures the new user shows up immediately in the usages above."),(0,s.kt)("details",{open:!0},(0,s.kt)("summary",null,(0,s.kt)("b",null,"userEndpoint.ts")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>)  => {\n    const updates = [\n      userList.bind().updater((users = []) => [newUser, ...users]),\n      userList.bind({ sortBy: 'createdAt' }).updater((users = [], { sortBy }) => {\n        const ret = [createdUser, ...users];\n        ret.sortBy(sortBy);\n        return ret;\n      },\n    ];\n    if (newUser.isAdmin) {\n      updates.push(userList.bind({ admin: true }).updater((users = []) => [newUser, ...users]));\n    }\n    return updates;\n  },\n});\n"))),(0,s.kt)("h4",{id:"extracting-patterns"},"Extracting patterns"),(0,s.kt)("p",null,"In case more than one other endpoint might result in updating our list endpoint, we can centralize the logic of how that should work in our updated endpoint."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const userList = new Endpoint(getUsers, {\n  schema: User[],\n  addUserUpdater: (this: Endpoint, newUser: User) => this.updater((users = []) => [newUser, ...users]),\n});\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>) => [\n    userList.bind({ admin: true }).addUserUpate(newUser),\n    userList.bind({}).addUserUpate(newUser),\n  ],\n});\n")),(0,s.kt)("details",{open:!0},(0,s.kt)("summary",null,(0,s.kt)("b",null,"Alternate Ideas - The programmatic approach")),(0,s.kt)("h4",{id:"the-no-guarantees"},"The no guarantees"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>, state: State<unknown>) => {\n    return {\n      ...state,\n      results: {\n        ...state.results,\n       [userList.key({ admin: true })]: [newUser.pk(), ...state.results[userList.key({ admin: true })]],\n       [userList.key({ })]: [newUser.pk(), ...state.results[userList.key({ })]],\n     }\n    }\n  }\n}\n")),(0,s.kt)("h4",{id:"store-adapter"},"Store Adapter"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>, store: Store) => {\n    const prependUser = (users = []) => [newUser, ...users]\n    if (newUser.isAdmin) {\n      store = store.set(\n         userList.bind({admin: true}),\n         prependUser\n      );\n    }\n    store = store.set(\n       userList.bind({}),\n       prependUser\n    );\n    return store;\n  }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createUser = new Endpoint(postToUserFunction, {\n  schema: User,\n  update: (newUser: Denormalize<S>, store: Store) => {\n    // this actually goes through every current result based on this endpoint\n    // however it does not update extremely stale results for performance reasons\n    store.get(userList).mapItems((key: string, users: User[]) => {\n      if (!key.includes('admin') || newUser.isAdmin) {\n        return [newUser, ...users];\n      }\n    });\n  }\n}\n")),(0,s.kt)("p",null,"Another idea is to make an updater callback with identical API to ",(0,s.kt)("a",{parentName:"p",href:"https://resthooks.io/docs/api/Manager#getmiddleware"},"manager middleware"),". We would probably want to minimize chaining actions, so some way of consolidating into one action would be preferable. Adding an adapter to raw state might be good for Manager's as well, so designing this interface could be beneficial to optionally improving middleware interfaces.")),(0,s.kt)("h3",{id:"resolution-order"},"Resolution order"),(0,s.kt)("p",null,"This makes little difference in React 18 since renders are batched; however in React < 18, this means that code after promise resolution will be executed before react renders - allowing actions that need to take place as a result of successful fetch. For example navigating off a deleted page after delete."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const handleDelete = useCallback(\n  async e => {\n    await fetch(MyResource.delete(), { id });\n    history.push('/');\n  },\n  [fetch, id],\n);\n")),(0,s.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"It's now recommended to wrap all fetches in act when testing like so:"),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"    await act(async () => {\n      await result.current.fetch(ComplexResource.detail(), {\n        id: '5',\n      });\n    });\n")))),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/coinbase/rest-hooks/pull/1046"},"PR")),(0,s.kt)("h2",{id:"resourcelistpaginated"},"Resource.list().paginated()"),(0,s.kt)("h3",{id:"motivation-1"},"Motivation"),(0,s.kt)("p",null,"Pagination is a common scenario, that would benefit from minimal specification."),(0,s.kt)("h3",{id:"solution"},"Solution"),(0,s.kt)("p",null,"By default we rely on finding a list within the schema. The only remaining thing is figuring out how to extract the 'cursor' args to update the main list. Therefore, a function to do just that should be provided by the user like so."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class NewsResource extends Resource {\n  static listPage<T extends typeof NewsResource>(this: T) {\n    return this.list().paginated(({ cursor, ...rest }) => [rest]);\n  }\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useResource } from 'rest-hooks';\nimport NewsResource from 'resources/NewsResource';\n\nfunction NewsList() {\n  const { results, cursor } = useResource(NewsResource.list(), {});\n  const curRef = useRef(cursor);\n  curRef.current = cursor;\n  const fetch = useFetcher();\n  const getNextPage = useCallback(\n    () => fetch(NewsResource.listPage(), { cursor: curRef.current }),\n    []\n  );\n\n  return (\n    <Pagination onPaginate={getNextPage} nextCursor={cursor}>\n      <NewsList data={results} />\n    </Pagination>\n  );\n}\n")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/coinbase/rest-hooks/pull/868"},"PR")))}c.isMDXComponent=!0}}]);